"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap+suggestion@2.11.5_@tiptap+core@2.11.5_@tiptap+pm@2.11.5__@tiptap+pm@2.11.5";
exports.ids = ["vendor-chunks/@tiptap+suggestion@2.11.5_@tiptap+core@2.11.5_@tiptap+pm@2.11.5__@tiptap+pm@2.11.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@tiptap+suggestion@2.11.5_@tiptap+core@2.11.5_@tiptap+pm@2.11.5__@tiptap+pm@2.11.5/node_modules/@tiptap/suggestion/dist/index.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tiptap+suggestion@2.11.5_@tiptap+core@2.11.5_@tiptap+pm@2.11.5__@tiptap+pm@2.11.5/node_modules/@tiptap/suggestion/dist/index.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Suggestion: () => (/* binding */ Suggestion),\n/* harmony export */   SuggestionPluginKey: () => (/* binding */ SuggestionPluginKey),\n/* harmony export */   \"default\": () => (/* binding */ Suggestion),\n/* harmony export */   findSuggestionMatch: () => (/* binding */ findSuggestionMatch)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/.pnpm/@tiptap+pm@2.11.5/node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/.pnpm/@tiptap+pm@2.11.5/node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/.pnpm/@tiptap+core@2.11.5_@tiptap+pm@2.11.5/node_modules/@tiptap/core/dist/index.js\");\n\n\n\n\nfunction findSuggestionMatch(config) {\n    var _a;\n    const { char, allowSpaces: allowSpacesOption, allowToIncludeChar, allowedPrefixes, startOfLine, $position, } = config;\n    const allowSpaces = allowSpacesOption && !allowToIncludeChar;\n    const escapedChar = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx)(char);\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\n    const prefix = startOfLine ? '^' : '';\n    const finalEscapedChar = allowToIncludeChar ? '' : escapedChar;\n    const regexp = allowSpaces\n        ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${finalEscapedChar}|$)`, 'gm')\n        : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${finalEscapedChar}]*`, 'gm');\n    const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;\n    if (!text) {\n        return null;\n    }\n    const textFrom = $position.pos - text.length;\n    const match = Array.from(text.matchAll(regexp)).pop();\n    if (!match || match.input === undefined || match.index === undefined) {\n        return null;\n    }\n    // JavaScript doesn't have lookbehinds. This hacks a check that first character\n    // is a space or the start of the line\n    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n    const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join('')}\\0]?$`).test(matchPrefix);\n    if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n        return null;\n    }\n    // The absolute position of the match in the document\n    const from = textFrom + match.index;\n    let to = from + match[0].length;\n    // Edge case handling; if spaces are allowed and we're directly in between\n    // two triggers\n    if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n        match[0] += ' ';\n        to += 1;\n    }\n    // If the $position is located within the matched substring, return that range\n    if (from < $position.pos && to >= $position.pos) {\n        return {\n            range: {\n                from,\n                to,\n            },\n            query: match[0].slice(char.length),\n            text: match[0],\n        };\n    }\n    return null;\n}\n\nconst SuggestionPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('suggestion');\n/**\n * This utility allows you to create suggestions.\n * @see https://tiptap.dev/api/utilities/suggestion\n */\nfunction Suggestion({ pluginKey = SuggestionPluginKey, editor, char = '@', allowSpaces = false, allowToIncludeChar = false, allowedPrefixes = [' '], startOfLine = false, decorationTag = 'span', decorationClass = 'suggestion', command = () => null, items = () => [], render = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch, }) {\n    let props;\n    const renderer = render === null || render === void 0 ? void 0 : render();\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey,\n        view() {\n            return {\n                update: async (view, prevState) => {\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\n                    const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);\n                    // See how the state changed\n                    const moved = prev.active && next.active && prev.range.from !== next.range.from;\n                    const started = !prev.active && next.active;\n                    const stopped = prev.active && !next.active;\n                    const changed = !started && !stopped && prev.query !== next.query;\n                    const handleStart = started || (moved && changed);\n                    const handleChange = changed || moved;\n                    const handleExit = stopped || (moved && changed);\n                    // Cancel when suggestion isn't active\n                    if (!handleStart && !handleChange && !handleExit) {\n                        return;\n                    }\n                    const state = handleExit && !handleStart ? prev : next;\n                    const decorationNode = view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\n                    props = {\n                        editor,\n                        range: state.range,\n                        query: state.query,\n                        text: state.text,\n                        items: [],\n                        command: commandProps => {\n                            return command({\n                                editor,\n                                range: state.range,\n                                props: commandProps,\n                            });\n                        },\n                        decorationNode,\n                        // virtual node for popper.js or tippy.js\n                        // this can be used for building popups without a DOM node\n                        clientRect: decorationNode\n                            ? () => {\n                                var _a;\n                                // because of `items` can be asynchrounous weâ€™ll search for the current decoration node\n                                const { decorationId } = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state); // eslint-disable-line\n                                const currentDecorationNode = view.dom.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\n                                return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;\n                            }\n                            : null,\n                    };\n                    if (handleStart) {\n                        (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\n                    }\n                    if (handleChange || handleStart) {\n                        props.items = await items({\n                            editor,\n                            query: state.query,\n                        });\n                    }\n                    if (handleExit) {\n                        (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);\n                    }\n                    if (handleStart) {\n                        (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);\n                    }\n                },\n                destroy: () => {\n                    var _a;\n                    if (!props) {\n                        return;\n                    }\n                    (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\n                },\n            };\n        },\n        state: {\n            // Initialize the plugin's internal state.\n            init() {\n                const state = {\n                    active: false,\n                    range: {\n                        from: 0,\n                        to: 0,\n                    },\n                    query: null,\n                    text: null,\n                    composing: false,\n                };\n                return state;\n            },\n            // Apply changes to the plugin state from a view transaction.\n            apply(transaction, prev, _oldState, state) {\n                const { isEditable } = editor;\n                const { composing } = editor.view;\n                const { selection } = transaction;\n                const { empty, from } = selection;\n                const next = { ...prev };\n                next.composing = composing;\n                // We can only be suggesting if the view is editable, and:\n                //   * there is no selection, or\n                //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\n                if (isEditable && (empty || editor.view.composing)) {\n                    // Reset active state if we just left the previous suggestion range\n                    if ((from < prev.range.from || from > prev.range.to) && !composing && !prev.composing) {\n                        next.active = false;\n                    }\n                    // Try to match against where our cursor currently is\n                    const match = findSuggestionMatch$1({\n                        char,\n                        allowSpaces,\n                        allowToIncludeChar,\n                        allowedPrefixes,\n                        startOfLine,\n                        $position: selection.$from,\n                    });\n                    const decorationId = `id_${Math.floor(Math.random() * 0xffffffff)}`;\n                    // If we found a match, update the current state to show it\n                    if (match && allow({\n                        editor, state, range: match.range, isActive: prev.active,\n                    })) {\n                        next.active = true;\n                        next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\n                        next.range = match.range;\n                        next.query = match.query;\n                        next.text = match.text;\n                    }\n                    else {\n                        next.active = false;\n                    }\n                }\n                else {\n                    next.active = false;\n                }\n                // Make sure to empty the range if suggestion is inactive\n                if (!next.active) {\n                    next.decorationId = null;\n                    next.range = { from: 0, to: 0 };\n                    next.query = null;\n                    next.text = null;\n                }\n                return next;\n            },\n        },\n        props: {\n            // Call the keydown hook if suggestion is active.\n            handleKeyDown(view, event) {\n                var _a;\n                const { active, range } = plugin.getState(view.state);\n                if (!active) {\n                    return false;\n                }\n                return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;\n            },\n            // Setup decorator on the currently active suggestion.\n            decorations(state) {\n                const { active, range, decorationId } = plugin.getState(state);\n                if (!active) {\n                    return null;\n                }\n                return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(state.doc, [\n                    _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.inline(range.from, range.to, {\n                        nodeName: decorationTag,\n                        class: decorationClass,\n                        'data-decoration-id': decorationId,\n                    }),\n                ]);\n            },\n        },\n    });\n    return plugin;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRpcHRhcCtzdWdnZXN0aW9uQDIuMTEuNV9AdGlwdGFwK2NvcmVAMi4xMS41X0B0aXB0YXArcG1AMi4xMS41X19AdGlwdGFwK3BtQDIuMTEuNS9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdWdnZXN0aW9uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxRDtBQUNPO0FBQ2Q7O0FBRTlDO0FBQ0E7QUFDQSxZQUFZLHFHQUFxRztBQUNqSDtBQUNBLHdCQUF3Qiw0REFBYztBQUN0QyxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxFQUFFLFlBQVksV0FBVyxpQkFBaUI7QUFDekUsd0JBQXdCLE9BQU8sUUFBUSxZQUFZLE9BQU8saUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyRkFBMkY7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx1REFBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzUUFBc1EsMEZBQTBGO0FBQ3RYO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixtQkFBbUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZSxrRkFBa0Y7QUFDekksNkdBQTZHLGFBQWE7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQyx3QkFBd0IsWUFBWTtBQUNwQyx3QkFBd0IsWUFBWTtBQUNwQyx3QkFBd0IsY0FBYztBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwrQ0FBK0MsdUNBQXVDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLCtKQUErSixvQkFBb0I7QUFDbkwsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBYTtBQUNwQyxvQkFBb0IsdURBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTs7QUFFdUY7QUFDdkYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rcmlzdG9mZmVyd2luZG9sZi9TaXRlcy9tcmt3L25vZGVfbW9kdWxlcy8ucG5wbS9AdGlwdGFwK3N1Z2dlc3Rpb25AMi4xMS41X0B0aXB0YXArY29yZUAyLjExLjVfQHRpcHRhcCtwbUAyLjExLjVfX0B0aXB0YXArcG1AMi4xMS41L25vZGVfbW9kdWxlcy9AdGlwdGFwL3N1Z2dlc3Rpb24vZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW5LZXksIFBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldyc7XG5pbXBvcnQgeyBlc2NhcGVGb3JSZWdFeCB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbmZ1bmN0aW9uIGZpbmRTdWdnZXN0aW9uTWF0Y2goY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgY2hhciwgYWxsb3dTcGFjZXM6IGFsbG93U3BhY2VzT3B0aW9uLCBhbGxvd1RvSW5jbHVkZUNoYXIsIGFsbG93ZWRQcmVmaXhlcywgc3RhcnRPZkxpbmUsICRwb3NpdGlvbiwgfSA9IGNvbmZpZztcbiAgICBjb25zdCBhbGxvd1NwYWNlcyA9IGFsbG93U3BhY2VzT3B0aW9uICYmICFhbGxvd1RvSW5jbHVkZUNoYXI7XG4gICAgY29uc3QgZXNjYXBlZENoYXIgPSBlc2NhcGVGb3JSZWdFeChjaGFyKTtcbiAgICBjb25zdCBzdWZmaXggPSBuZXcgUmVnRXhwKGBcXFxccyR7ZXNjYXBlZENoYXJ9JGApO1xuICAgIGNvbnN0IHByZWZpeCA9IHN0YXJ0T2ZMaW5lID8gJ14nIDogJyc7XG4gICAgY29uc3QgZmluYWxFc2NhcGVkQ2hhciA9IGFsbG93VG9JbmNsdWRlQ2hhciA/ICcnIDogZXNjYXBlZENoYXI7XG4gICAgY29uc3QgcmVnZXhwID0gYWxsb3dTcGFjZXNcbiAgICAgICAgPyBuZXcgUmVnRXhwKGAke3ByZWZpeH0ke2VzY2FwZWRDaGFyfS4qPyg/PVxcXFxzJHtmaW5hbEVzY2FwZWRDaGFyfXwkKWAsICdnbScpXG4gICAgICAgIDogbmV3IFJlZ0V4cChgJHtwcmVmaXh9KD86Xik/JHtlc2NhcGVkQ2hhcn1bXlxcXFxzJHtmaW5hbEVzY2FwZWRDaGFyfV0qYCwgJ2dtJyk7XG4gICAgY29uc3QgdGV4dCA9ICgoX2EgPSAkcG9zaXRpb24ubm9kZUJlZm9yZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVGV4dCkgJiYgJHBvc2l0aW9uLm5vZGVCZWZvcmUudGV4dDtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRleHRGcm9tID0gJHBvc2l0aW9uLnBvcyAtIHRleHQubGVuZ3RoO1xuICAgIGNvbnN0IG1hdGNoID0gQXJyYXkuZnJvbSh0ZXh0Lm1hdGNoQWxsKHJlZ2V4cCkpLnBvcCgpO1xuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5wdXQgPT09IHVuZGVmaW5lZCB8fCBtYXRjaC5pbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBKYXZhU2NyaXB0IGRvZXNuJ3QgaGF2ZSBsb29rYmVoaW5kcy4gVGhpcyBoYWNrcyBhIGNoZWNrIHRoYXQgZmlyc3QgY2hhcmFjdGVyXG4gICAgLy8gaXMgYSBzcGFjZSBvciB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcbiAgICBjb25zdCBtYXRjaFByZWZpeCA9IG1hdGNoLmlucHV0LnNsaWNlKE1hdGgubWF4KDAsIG1hdGNoLmluZGV4IC0gMSksIG1hdGNoLmluZGV4KTtcbiAgICBjb25zdCBtYXRjaFByZWZpeElzQWxsb3dlZCA9IG5ldyBSZWdFeHAoYF5bJHthbGxvd2VkUHJlZml4ZXMgPT09IG51bGwgfHwgYWxsb3dlZFByZWZpeGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxvd2VkUHJlZml4ZXMuam9pbignJyl9XFwwXT8kYCkudGVzdChtYXRjaFByZWZpeCk7XG4gICAgaWYgKGFsbG93ZWRQcmVmaXhlcyAhPT0gbnVsbCAmJiAhbWF0Y2hQcmVmaXhJc0FsbG93ZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbWF0Y2ggaW4gdGhlIGRvY3VtZW50XG4gICAgY29uc3QgZnJvbSA9IHRleHRGcm9tICsgbWF0Y2guaW5kZXg7XG4gICAgbGV0IHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAvLyBFZGdlIGNhc2UgaGFuZGxpbmc7IGlmIHNwYWNlcyBhcmUgYWxsb3dlZCBhbmQgd2UncmUgZGlyZWN0bHkgaW4gYmV0d2VlblxuICAgIC8vIHR3byB0cmlnZ2Vyc1xuICAgIGlmIChhbGxvd1NwYWNlcyAmJiBzdWZmaXgudGVzdCh0ZXh0LnNsaWNlKHRvIC0gMSwgdG8gKyAxKSkpIHtcbiAgICAgICAgbWF0Y2hbMF0gKz0gJyAnO1xuICAgICAgICB0byArPSAxO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgJHBvc2l0aW9uIGlzIGxvY2F0ZWQgd2l0aGluIHRoZSBtYXRjaGVkIHN1YnN0cmluZywgcmV0dXJuIHRoYXQgcmFuZ2VcbiAgICBpZiAoZnJvbSA8ICRwb3NpdGlvbi5wb3MgJiYgdG8gPj0gJHBvc2l0aW9uLnBvcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHF1ZXJ5OiBtYXRjaFswXS5zbGljZShjaGFyLmxlbmd0aCksXG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IFN1Z2dlc3Rpb25QbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdzdWdnZXN0aW9uJyk7XG4vKipcbiAqIFRoaXMgdXRpbGl0eSBhbGxvd3MgeW91IHRvIGNyZWF0ZSBzdWdnZXN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS91dGlsaXRpZXMvc3VnZ2VzdGlvblxuICovXG5mdW5jdGlvbiBTdWdnZXN0aW9uKHsgcGx1Z2luS2V5ID0gU3VnZ2VzdGlvblBsdWdpbktleSwgZWRpdG9yLCBjaGFyID0gJ0AnLCBhbGxvd1NwYWNlcyA9IGZhbHNlLCBhbGxvd1RvSW5jbHVkZUNoYXIgPSBmYWxzZSwgYWxsb3dlZFByZWZpeGVzID0gWycgJ10sIHN0YXJ0T2ZMaW5lID0gZmFsc2UsIGRlY29yYXRpb25UYWcgPSAnc3BhbicsIGRlY29yYXRpb25DbGFzcyA9ICdzdWdnZXN0aW9uJywgY29tbWFuZCA9ICgpID0+IG51bGwsIGl0ZW1zID0gKCkgPT4gW10sIHJlbmRlciA9ICgpID0+ICh7fSksIGFsbG93ID0gKCkgPT4gdHJ1ZSwgZmluZFN1Z2dlc3Rpb25NYXRjaDogZmluZFN1Z2dlc3Rpb25NYXRjaCQxID0gZmluZFN1Z2dlc3Rpb25NYXRjaCwgfSkge1xuICAgIGxldCBwcm9wcztcbiAgICBjb25zdCByZW5kZXJlciA9IHJlbmRlciA9PT0gbnVsbCB8fCByZW5kZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcigpO1xuICAgIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IHBsdWdpbktleSxcbiAgICAgICAgdmlldygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBhc3luYyAodmlldywgcHJldlN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IChfYSA9IHRoaXMua2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdGUocHJldlN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IChfYiA9IHRoaXMua2V5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBob3cgdGhlIHN0YXRlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW92ZWQgPSBwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZSAmJiBwcmV2LnJhbmdlLmZyb20gIT09IG5leHQucmFuZ2UuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRlZCA9ICFwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcHBlZCA9IHByZXYuYWN0aXZlICYmICFuZXh0LmFjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlZCA9ICFzdGFydGVkICYmICFzdG9wcGVkICYmIHByZXYucXVlcnkgIT09IG5leHQucXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZVN0YXJ0ID0gc3RhcnRlZCB8fCAobW92ZWQgJiYgY2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IGNoYW5nZWQgfHwgbW92ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUV4aXQgPSBzdG9wcGVkIHx8IChtb3ZlZCAmJiBjaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIHdoZW4gc3VnZ2VzdGlvbiBpc24ndCBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVTdGFydCAmJiAhaGFuZGxlQ2hhbmdlICYmICFoYW5kbGVFeGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBoYW5kbGVFeGl0ICYmICFoYW5kbGVTdGFydCA/IHByZXYgOiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uTm9kZSA9IHZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke3N0YXRlLmRlY29yYXRpb25JZH1cIl1gKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdGF0ZS50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZFByb3BzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLnJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogY29tbWFuZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25Ob2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlydHVhbCBub2RlIGZvciBwb3BwZXIuanMgb3IgdGlwcHkuanNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIGJlIHVzZWQgZm9yIGJ1aWxkaW5nIHBvcHVwcyB3aXRob3V0IGEgRE9NIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFJlY3Q6IGRlY29yYXRpb25Ob2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBvZiBgaXRlbXNgIGNhbiBiZSBhc3luY2hyb3Vub3VzIHdl4oCZbGwgc2VhcmNoIGZvciB0aGUgY3VycmVudCBkZWNvcmF0aW9uIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWNvcmF0aW9uSWQgfSA9IChfYSA9IHRoaXMua2V5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdGUoZWRpdG9yLnN0YXRlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGVjb3JhdGlvbk5vZGUgPSB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHtkZWNvcmF0aW9uSWR9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3VycmVudERlY29yYXRpb25Ob2RlID09PSBudWxsIHx8IGN1cnJlbnREZWNvcmF0aW9uTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERlY29yYXRpb25Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uQmVmb3JlU3RhcnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHJlbmRlcmVyLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9kID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uQmVmb3JlVXBkYXRlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChyZW5kZXJlciwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVDaGFuZ2UgfHwgaGFuZGxlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLml0ZW1zID0gYXdhaXQgaXRlbXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlRXhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9lID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uRXhpdCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwocmVuZGVyZXIsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2YgPSByZW5kZXJlciA9PT0gbnVsbCB8fCByZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZXIub25VcGRhdGUpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKHJlbmRlcmVyLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2cgPSByZW5kZXJlciA9PT0gbnVsbCB8fCByZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZXIub25TdGFydCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmNhbGwocmVuZGVyZXIsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX2EgPSByZW5kZXJlciA9PT0gbnVsbCB8fCByZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVuZGVyZXIub25FeGl0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChyZW5kZXJlciwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcGx1Z2luJ3MgaW50ZXJuYWwgc3RhdGUuXG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBBcHBseSBjaGFuZ2VzIHRvIHRoZSBwbHVnaW4gc3RhdGUgZnJvbSBhIHZpZXcgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICBhcHBseSh0cmFuc2FjdGlvbiwgcHJldiwgX29sZFN0YXRlLCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gZWRpdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29tcG9zaW5nIH0gPSBlZGl0b3IudmlldztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB7IC4uLnByZXYgfTtcbiAgICAgICAgICAgICAgICBuZXh0LmNvbXBvc2luZyA9IGNvbXBvc2luZztcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gb25seSBiZSBzdWdnZXN0aW5nIGlmIHRoZSB2aWV3IGlzIGVkaXRhYmxlLCBhbmQ6XG4gICAgICAgICAgICAgICAgLy8gICAqIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiwgb3JcbiAgICAgICAgICAgICAgICAvLyAgICogYSBjb21wb3NpdGlvbiBpcyBhY3RpdmUgKHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNDQ5KVxuICAgICAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlICYmIChlbXB0eSB8fCBlZGl0b3Iudmlldy5jb21wb3NpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGFjdGl2ZSBzdGF0ZSBpZiB3ZSBqdXN0IGxlZnQgdGhlIHByZXZpb3VzIHN1Z2dlc3Rpb24gcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmcm9tIDwgcHJldi5yYW5nZS5mcm9tIHx8IGZyb20gPiBwcmV2LnJhbmdlLnRvKSAmJiAhY29tcG9zaW5nICYmICFwcmV2LmNvbXBvc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYWdhaW5zdCB3aGVyZSBvdXIgY3Vyc29yIGN1cnJlbnRseSBpc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGZpbmRTdWdnZXN0aW9uTWF0Y2gkMSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTcGFjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1RvSW5jbHVkZUNoYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkUHJlZml4ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICRwb3NpdGlvbjogc2VsZWN0aW9uLiRmcm9tLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbklkID0gYGlkXyR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZil9YDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBtYXRjaCwgdXBkYXRlIHRoZSBjdXJyZW50IHN0YXRlIHRvIHNob3cgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIGFsbG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvciwgc3RhdGUsIHJhbmdlOiBtYXRjaC5yYW5nZSwgaXNBY3RpdmU6IHByZXYuYWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kZWNvcmF0aW9uSWQgPSBwcmV2LmRlY29yYXRpb25JZCA/IHByZXYuZGVjb3JhdGlvbklkIDogZGVjb3JhdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5yYW5nZSA9IG1hdGNoLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5xdWVyeSA9IG1hdGNoLnF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50ZXh0ID0gbWF0Y2gudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBlbXB0eSB0aGUgcmFuZ2UgaWYgc3VnZ2VzdGlvbiBpcyBpbmFjdGl2ZVxuICAgICAgICAgICAgICAgIGlmICghbmV4dC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZWNvcmF0aW9uSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJhbmdlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC50ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgLy8gQ2FsbCB0aGUga2V5ZG93biBob29rIGlmIHN1Z2dlc3Rpb24gaXMgYWN0aXZlLlxuICAgICAgICAgICAgaGFuZGxlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFjdGl2ZSwgcmFuZ2UgfSA9IHBsdWdpbi5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoKF9hID0gcmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLm9uS2V5RG93bikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocmVuZGVyZXIsIHsgdmlldywgZXZlbnQsIHJhbmdlIH0pKSB8fCBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBTZXR1cCBkZWNvcmF0b3Igb24gdGhlIGN1cnJlbnRseSBhY3RpdmUgc3VnZ2VzdGlvbi5cbiAgICAgICAgICAgIGRlY29yYXRpb25zKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhY3RpdmUsIHJhbmdlLCBkZWNvcmF0aW9uSWQgfSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtcbiAgICAgICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5pbmxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBkZWNvcmF0aW9uVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGRlY29yYXRpb25DbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWRlY29yYXRpb24taWQnOiBkZWNvcmF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gcGx1Z2luO1xufVxuXG5leHBvcnQgeyBTdWdnZXN0aW9uLCBTdWdnZXN0aW9uUGx1Z2luS2V5LCBTdWdnZXN0aW9uIGFzIGRlZmF1bHQsIGZpbmRTdWdnZXN0aW9uTWF0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tiptap+suggestion@2.11.5_@tiptap+core@2.11.5_@tiptap+pm@2.11.5__@tiptap+pm@2.11.5/node_modules/@tiptap/suggestion/dist/index.js\n");

/***/ })

};
;